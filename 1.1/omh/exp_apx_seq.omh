/* --------------------------------------------------------------------------
CppAD: C++ Algorithmic Differentiation: Copyright (C) 2003-06 Bradley M. Bell

CppAD is distributed under multiple licenses. This distribution is under
the terms of the 
                    Common Public License Version 1.0.

A copy of this license is included in the COPYING file of this distribution.
Please visit http://www.coin-or.org/CppAD/ for information on other licenses.
-------------------------------------------------------------------------- */
/*
$begin ExpApxSeq$$
$spell
	cpp
	ExpApxSeq
	bool
$$

$section An Example Operation Sequence$$

$index ExpApx, operation sequence$$
$index example, operation sequence$$
$index operation, sequence$$
$index sequence, operation$$

$head Operation Sequence$$
An atomic $italic Type$$ operation is an operation
that has a $italic Type$$ result and is not made up of 
other more basic operations.
A sequence of atomic $italic Type$$ operations is called a
$italic Type$$ operation sequence.
Given an C++ algorithm and its inputs,
there is a corresponding $italic Type$$ operation sequence for each type. 
If $italic Type$$ is clear from the context, 
we drop it and just refer to the operation sequence.

$head Mathematical Form$$
Suppose that we use the algorithm $xref/ExpApx.hpp/$$
to compute $latex {\rm ExpApx} (x, e)$$ 
with $latex x$$ is equal to .5
and $latex e$$ is equal to .2. 
For this case, our approximation of the exponential function is
$latex \[
{\rm ExpApx} (x, e) =   1 + x + x^2 / 2 
=   1 + .5 + .25 / 2 
=   1.625
\] $$


$head Parameter$$
The initialization section always sets
$latex r_0$$,
$latex s_0$$,
and
$latex k_0$$ equal to one.
Hence the $italic Type$$ values 
$latex r_0$$, $latex s_0$$ and $latex k_0$$ do not
depend on the input variables $italic x$$ or $italic e$$.
We refer to symbols that do not depend on the input variables
as operation sequence parameters.
We refer to other symbols as operation sequence variables. 


$head Example Operation Sequence$$
In the table below, 
the C++ source code is listed on the left,
the corresponding symbol is in the next column,
the atomic operation is in the next column,
and the resulting value of the symbol when 
$latex x = .5$$ and $latex e = .2$$ is listed on the right.
Note that the comparisons
$code r > e$$ and $code  Type(0) > x $$
have results of type
$code bool$$ and hence are not part of the operation sequence.
We use the symbol $latex v_j$$ for the value assigned
to the object $latex v$$ in the $th j$$ execution of loop in the algorithm.
$center
$table
$bold Code$$ 
	$cnext $pre  $$ $cnext $bold Operation$$
	$cnext $pre  $$ $cnext $bold Value$$
	$rnext
$code a = x$$
	$cnext $cnext $latex a_0 = x $$ 
	$cnext $cnext = 0.5      
$rnext
$code q  = a * r$$
	$cnext $cnext $latex q_1 = r_0 * a_0 $$ 
	$cnext $cnext = 0.5      
$rnext
$code r  = q / k$$
	$cnext $cnext $latex r_1 = q_1 / k_0 $$ 
	$cnext $cnext = 0.5      
$rnext
$code s  = s + r$$
	$cnext $cnext $latex s_1 = s_0 + r_1 $$ 
	$cnext $cnext = 1.5      
$rnext
$code k  = k + Type(1)$$
	$cnext $cnext $latex k_1 = k_0 + 1 $$ 
	$cnext $cnext = 2        
$rnext
$code q  = a * r$$
	$cnext $cnext $latex q_2 = r_1 * a_0 $$ 
	$cnext $cnext = 0.25     
$rnext
$code r  = q / k$$
	$cnext $cnext $latex r_2 = q_2 / k_1 $$ 
	$cnext $cnext = 0.125    
$rnext
$code s  = s + r$$
	$cnext $cnext $latex s_2 = s_1 + r_2 $$ 
	$cnext $cnext = 1.625    
$rnext
$code k  = k + Type(1)$$
	$cnext $cnext $latex k_2 = k_1 + 1 $$ 
	$cnext $cnext = 3        
$tend
$$
The return value of the algorithm for this case is
$latex s_2$$ which is equal to 1.625.

$head Comparisons$$
If $latex x$$ were negative,
or if $latex e$$ were a much smaller or much larger value,
the results of the following comparisons could be different:
$codep
	if( Type(0) > x ) 
	while(r > e)
$$
This in turn would result in a different operation sequence.
Thus the operation sequence above only correspond to the our algorithm
for values of $latex x$$ and $latex e$$ within a certain range.
Note that there is a neighborhood
of $latex x = 0.5$$ for which the comparisons would have the 
same result and hence the operation sequence would be the same.

$head Symbols$$
$index operation, symbol$$
$index symbol, operation$$
The symbols for an operation sequence is a
sequence of unique names for each atomic operation.
For example, the symbols for the operation sequence above are:
$latex \[
	r_0, s_0, k_0, a_0, q_1, r_1, s_1, k_1, q_2, r_2, s_2
\]$$
In an abuse of notation, we use a symbol for both the
function and the value of the function corresponding to an atomic operation. 
Note that each time a $italic Type$$ object is assigned a value
there is a different symbol corresponding to the assignment.

$children%
	introduction/exp_apx_seq.cpp
%$$
$head Verification$$
The file $xref/ExpApxSeq.cpp/$$ contains a routine 
which verifies the values computed above.
It returns true for success and false for failure.

$end
*/
