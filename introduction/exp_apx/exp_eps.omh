-----------------------------------------------------------------------------
CppAD: C++ Algorithmic Differentiation: Copyright (C) 2003-07 Bradley M. Bell

CppAD is distributed under multiple licenses. This distribution is under
the terms of the 
                    Common Public License Version 1.0.

A copy of this license is included in the COPYING file of this distribution.
Please visit http://www.coin-or.org/CppAD/ for information on other licenses.
-----------------------------------------------------------------------------
$begin exp_eps.hpp$$
$spell
	exp_eps
$$

$section exp_eps: Implementation$$
$index implementation, exp_eps$$
$index exp_eps, implementation$$

$code
$verbatim%introduction/exp_apx/exp_eps.hpp%0%// BEGIN PROGRAM%// END PROGRAM%$$
$$

$end
-----------------------------------------------------------------------------
$begin exp_eps.cpp$$
$spell
	exp_eps
$$

$section exp_eps: Test of exp_eps$$
$index test, exp_eps$$
$index exp_eps, test$$

$code
$verbatim%introduction/exp_apx/exp_eps.cpp%0%// BEGIN PROGRAM%// END PROGRAM%$$
$$

$end
-----------------------------------------------------------------------------
$begin exp_eps_seq$$
$spell
	cpp
	exp_eps_seq
	bool
$$

$section exp_eps: Operation Sequence and Zero Order Forward Mode$$

$index exp_eps, operation sequence$$
$index example, operation sequence$$
$index operation, sequence example$$
$index sequence, example operation$$

$index zero, order forward$$
$index order, zero forward$$
$index forward, zero order$$

$head Mathematical Form$$
Suppose that we use the algorithm $xref/exp_eps.hpp/$$
to compute $syntax%exp_eps(%x%, %epsilon%)%$$
with $italic x$$ is equal to .5
and $italic epsilon$$ is equal to .2. 
For this case, function corresponding to the $code exp_eps$$
has the following form and function value:
$latex \[
\begin{array}{rclll}
{\rm exp\_apx} ( x , \varepsilon ) & = &   1 + x + x^2 / 2  
	& =   1 + .5 + 0.125 
	& =   1.625
\end{array}
\] $$


$head Operation Sequence$$
We consider the 
$cref/operation sequence/glossary/Operation/Sequence/$$
corresponding to the algorithm $xref/exp_eps.hpp/$$
with the argument $italic x$$ is equal to .5
and $italic epsilon$$ is equal to .2. 

$subhead Variable$$
We refer to values that depend on the input variables
$italic x$$ and $italic epsilon$$ as variables.

$subhead Parameter$$
We refer to values that do not depend on the input variables
$italic x$$ or $italic epsilon$$ as parameters.
Operations where the result is a parameter are not traced
in the operation sequence below.


$subhead Index$$
The Index column contains the index in the operation sequence
of the corresponding atomic operation and variable. 
A Forward sweep starts with the first operation 
and ends with the last.

$subhead Code$$
The Code column contains the C++ source code corresponding 
to the corresponding atomic operation in the sequence. 

$subhead Operation$$
The Operation column contains the 
mathematical function corresponding to each atomic operation in the sequence.

$subhead Zero Order$$
The Zero Order column contains the variable value
corresponding to each atomic operation in the sequence.
These are also called the zero order forward mode values.
Forward mode refers to the fact that
the computations are done in the same order as the original algorithm; i.e,
in order of increasing index.
Zero order refers to the fact that variable values are
zero order derivatives.


$subhead Trace$$
$center
$table
$bold Index$$
	$cnext $pre  $$ $cnext $bold Code$$ 
	$cnext $pre  $$ $cnext $bold Operation$$
	$cnext $pre  $$ $cnext $bold Zero Order$$
$rnext
1
	$cnext $pre  $$ $cnext $code abs_x = x;$$
	$cnext $cnext $latex v_1 = x $$ 
	$cnext $cnext = 0.5      
$rnext
2
	$cnext $pre  $$ $cnext $code temp  = term * abs_x;$$
	$cnext $cnext $latex v_2 = 1 * v_1 $$ 
	$cnext $cnext = 0.5      
$rnext
3
	$cnext $pre  $$ $cnext $code term = temp / Type(k);$$
	$cnext $cnext $latex v_3 = v_2 / 1$$ 
	$cnext $cnext = 0.5      
$rnext
4
	$cnext $pre  $$ $cnext $code sum  = sum + term;$$
	$cnext $cnext $latex v_4 = 1 + v_3 $$ 
	$cnext $cnext = 1.5      
$rnext
5
	$cnext $pre  $$ $cnext  $code temp  = term * abs_x;$$
	$cnext $cnext $latex v_5 = v_3 * v_1 $$ 
	$cnext $cnext = 0.25     
$rnext
6
	$cnext $pre  $$ $cnext $code term = temp / Type(k);$$
	$cnext $cnext $latex v_6 = v_5 / 2$$ 
	$cnext $cnext = 0.125    
$rnext
7
	$cnext $pre  $$ $cnext $code sum  = sum + term;$$
	$cnext $cnext $latex v_7 = v_4 + v_6 $$ 
	$cnext $cnext = 1.625    
$tend
$$

$head Return  Value$$
The return value of the algorithm for this case is
$latex v_7$$ which is equal to 1.625.

$head Comparisons$$
If $italic x$$ were negative,
or if $italic epsilon$$ were a much smaller or much larger value,
the results of the following comparisons could be different:
$codep
	if( Type(0) > x ) 
	while(term > epsilon)
$$
This in turn would result in a different operation sequence.
Thus the operation sequence above only corresponds to 
$cref/exp_eps.hpp/$$
for values of $italic x$$ and $italic epsilon$$ within a certain range.
Note that there is a neighborhood
of $latex x = 0.5$$ for which the comparisons would have the 
same result and hence the operation sequence would be the same.

$children%
	introduction/exp_apx/exp_eps_seq.cpp
%$$

$head Verification$$
The file $xref/exp_eps_seq.cpp/$$ contains a routine 
that verifies the values computed above.
It returns true for success and false for failure.

$head Exercises$$
$list number$$
Suppose that $latex x = .1$$,
what is the result of a zero order forward sweep for 
the operation sequence above; 
i.e., what are the corresponding values for
$latex v_1 , v_2 , \ldots , v_7$$.
$lnext
Create a modified version of 
$cref/exp_eps_seq.cpp/$$ that verifies the values you obtained
for the previous exercise.
$lnext
Create and run a main program that reports the result of calling 
the modified version 
of $cref/exp_eps_seq.cpp/$$ in the previous exercise.
$lend

$end
-----------------------------------------------------------------------------
$begin exp_eps_for$$
$spell
	exp_eps_for
$$

$section exp_eps: First Order Forward Mode$$

$index first, order forward$$
$index order, first forward$$
$index forward, first order$$

$head Mathematical Form$$
Suppose that we use the algorithm $xref/exp_eps.hpp/$$
to compute $syntax%exp_eps(%x%, %epsilon%)%$$
with $italic x$$ is equal to .5
and $italic epsilon$$ is equal to .2. 
For this case, function corresponding to the 
$cref/exp_eps operation sequence/exp_eps_seq/Operation Sequence/$$
has the following form and partial derivative:
$latex \[
\begin{array}{rclll}
{\rm exp\_apx} ( x , \varepsilon ) & = &   1 + x + x^2 / 2  
\\
\partial_x {\rm exp\_apx} ( x , \varepsilon ) & = &   1 + x 
	& =   1 + .5 
	& =   1.5
\end{array}
\] $$

$head Operation Sequence$$
The corresponding 
$cref/operation sequence/exp_eps_seq/Operation Sequence/$$
and 
$cref/zero order/exp_eps_seq/Operation Sequence/Zero Order/$$
forward sweep values
are inputs that are need by a first order sweep.
A first order sweep 
computes the first order partial derivative
of all the dependent variables with respect to one independent variable. 
The $code exp_eps$$ operation sequence depends on $italic epsilon$$,
but for a given the operation sequence,
the values computed do not depend on $italic epsilon$$.
Thus, the partial derivative with respect to $italic epsilon$$,
of any of the variables in the operation sequence,
is zero.

$subhead Index$$
The Index column contains the index in the operation sequence
of the corresponding atomic operation. 
A Forward sweep starts with the first operation 
and ends with the last.

$subhead Operation$$
The Operation column contains the 
mathematical function corresponding to each atomic operation in the sequence.

$subhead Zero Order$$
The Zero Order column contains the function value
(zero order forward sweep value)
corresponding to each atomic operation in the sequence.

$subhead Partial$$
The Partial column contains the
mathematical function corresponding to the partial derivative
with respect to $italic x$$ for each operation in the sequence.

$subhead First Order$$
The First Order column contains the partial derivative value
(first order forward sweep value)
corresponding to each atomic operation in the sequence.

$subhead Trace$$

$center
$table
$bold Index$$
	$cnext $pre  $$ $cnext $bold Operation$$ 
	$cnext $pre  $$ $cnext $bold Zero Order$$
	$cnext $pre  $$ $cnext $bold Partial$$
	$cnext $pre  $$ $cnext $bold First Order$$
$rnext
1
	$cnext $pre  $$ $cnext $latex v_1 = x $$
	$cnext $cnext = 0.5
	$cnext $cnext 
	$latex \partial_x v_1 = \partial_x x  $$
	$cnext $cnext = 1
$rnext
2
	$cnext $pre  $$ $cnext $latex v_2 = 1 * v_1$$
	$cnext $cnext = 0.5
	$cnext $cnext 
	$latex \partial_x v_2 = 1 * \partial_x v_1$$
	$cnext $cnext = 1
$rnext
3
	$cnext $pre  $$ $cnext $latex v_3 = v_2 / 1$$
	$cnext $cnext = 0.5
	$cnext $cnext 
	$latex \partial_x v_3 = ( \partial_x v_2 ) / 1$$
	$cnext $cnext = 1
$rnext
4
	$cnext $pre  $$ $cnext $latex v_4 = 1 + v_3$$
	$cnext $cnext = 1.5
	$cnext $cnext 
	$latex \partial_x v_4 = \partial_x v_3 $$
	$cnext $cnext = 1
$rnext
5
	$cnext $pre  $$ $cnext $latex v_5 = v_3 * v_1$$
	$cnext $cnext = 0.25
	$cnext $cnext 
$latex \partial_x v_5 = ( \partial_x v_3 ) * v_1 + v_3 * ( \partial_x v_1 )$$
	$cnext $cnext = 1
$rnext
6
	$cnext $pre  $$ $cnext $latex v_6 = v_5 / 2$$
	$cnext $cnext = 0.125
	$cnext $cnext 
	$latex \partial_x v_6 = ( \partial_x v_5 ) / 2$$
	$cnext $cnext = 0.5
$rnext
7
	$cnext $pre  $$ $cnext $latex v_7 = v_4 + v_6$$
	$cnext $cnext = 1.625
	$cnext $cnext 
	$latex  \partial_x v_7 = \partial_x v_4 + \partial_x v_6$$
	$cnext $cnext = 1.5
$tend
$$
Thus forward mode returns
1.5 as the derivative of the return value $latex v_7$$ 
for this case.


$children%
	introduction/exp_apx/exp_eps_for.cpp
%$$

$head Verification$$
The file $xref/exp_eps_for.cpp/$$ contains a routine 
that verifies the values computed above.
It returns true for success and false for failure.

$head Exercises$$
$list number$$
Suppose that $latex x = .1$$,
what are the results of a zero and first order forward mode sweep for 
the operation sequence above; 
i.e., what are the corresponding values for
$latex v_1 , v_2 , \cdots , v_7$$ and
$latex \partial_x v_1 , \partial_x v_2 , \cdots , \partial_x v_7$$ ?
$lnext
Create a modified version of $cref/exp_eps_for.cpp/$$ that verifies 
the derivative values from the previous exercise.
Also create and run a main program that reports the result
of calling the modified version of
$cref/exp_eps_for.cpp/$$.
$lnext
Suppose that $latex x = .1$$ and $latex epsilon = .2$$,
what is the operation sequence corresponding to 
$syntax%
	exp_eps(%x%, %epsilon%)
%$$
$lend

$end
-----------------------------------------------------------------------------
$begin exp_eps_rev$$
$spell
	exp_eps_rev
$$

$section exp_eps: First Order Reverse Mode$$

$index first, order reverse$$
$index order, first reverse$$
$index reverse, first order$$

$head First Order Reverse$$
First order reverse mode uses the 
$cref/operation sequence/exp_eps_seq/Operation Sequence/$$
and 
$cref/zero order/exp_eps_seq/Operation Sequence/Zero Order/$$
forward sweep values
to compute the first order derivative
of one dependent variables with respect to all the independent variables. 
The computations are done in the reverse order of the original algorithm.

$head f_7$$
In reverse mode we choose one dependent variable and
compute its derivative with respect to all the independent variables.
For our example, we chose the value returned by $cref/exp_eps.hpp/$$
which is $latex v_7$$.
We begin with the function $latex f_7$$ where $latex v_7$$ 
is both an argument and the value of the function; i.e.,
$latex \[
\begin{array}{rcl}
f_7 ( v_1 , v_2 , v_3 , v_4 , v_5 , v_6 , v_7 ) & = & v_7 
\\
\D{f_7}{v_7} & = & 1
\end{array}
\] $$
All the other partial derivatives of $latex f_7$$ are zero.

$head Index 7: f_6$$
The last operation has index 7, 
$latex \[
	v_7 =   v_4 + v_6  
\] $$
We define the function 
$latex f_6 ( v_1 , v_2 , v_3 , v_4 , v_5 , v_6 ) $$
as equal to $latex f_7$$
except that $latex v_7$$ is eliminated using 
this operation; i.e.
$latex \[
f_6  = 
f_7 [ v_1 , v_2 , v_3 , v_4 , v_5 , v_6 , v_7 ( v_4 , v_6 ) ]
\] $$
It follows that 
$latex \[
\begin{array}{rcll}
\D{f_6}{v_4} 
& = & \D{f_7}{v_4} + 
	\D{f_7}{v_7} * \D{v_7}{v_4} 
& = 1
\\
\D{f_6}{v_6} 
& = & \D{f_7}{v_6} + 
	\D{f_7}{v_7} * \D{v_7}{v_6} 
& = 1
\end{array}
\] $$
All the other partial derivatives of $latex f_6$$ are zero.

$head Index 6: f_5$$
The previous operation has index 6, 
$latex \[
	v_6 = v_5 / 2
\] $$
We define the function 
$latex f_5 (  v_1 , v_2 , v_3 , v_4 , v_5 ) $$
as equal to $latex f_6 $$
except that $latex v_6 $$ is eliminated using this operation; i.e.,
$latex \[
f_5 = 
f_6 [  v_1 , v_2 , v_3 , v_4 , v_5 , v_6 ( v_5 ) ]
\] $$
It follows that 
$latex \[
\begin{array}{rcll}
\D{f_5}{v_4} 
& = & \D{f_6}{v_4} 
& = 1
\\
\D{f_5}{v_5} 
& = & \D{f_6}{v_5} + 
	\D{f_6}{v_6} * \D{v_6}{v_5} 
& = 0.5
\end{array}
\] $$
All the other partial derivatives of $latex f_5$$ are zero.

$head Index 5: f_4$$
The previous operation has index 5,
$latex \[
	v_5 = v_3 * v_1
\] $$
We define the function 
$latex f_4 (  v_1 , v_2 , v_3 , v_4 ) $$
as equal to $latex f_5 $$
except that $latex v_5 $$ is eliminated using this operation; i.e.,
$latex \[
f_4 = 
f_5 [  v_1 , v_2 , v_3 , v_4 , v_5 ( v_3 , v_1 )  ]
\] $$
Given the information from the forward sweep, we have
$latex v_3 =  0.5 $$ and $latex v_1 = 0.5 $$.
It follows that 
$latex \[
\begin{array}{rcll}
\D{f_4}{v_1} 
& = & \D{f_5}{v_1} + 
	\D{f_5}{v_5} * \D{v_5}{v_1} 
& =  0.25
\\
\D{f_4}{v_2} & = & \D{f_5}{v_2}  & = 0
\\
\D{f_4}{v_3} 
& = & \D{f_5}{v_3} + 
	\D{f_5}{v_5} * \D{v_5}{v_3} 
& =  0.25
\\
\D{f_4}{v_4}
& = & \D{f_5}{v_4} 
& = 1
\end{array}
\] $$

$head Index 4: f_3$$
The previous operation has index 4,
$latex \[
	v_4 = 1 + v_3
\] $$
We define the function 
$latex f_3 (  v_1 , v_2 , v_3 ) $$
as equal to $latex f_4 $$
except that $latex v_4 $$ is eliminated using this operation; i.e.,
$latex \[
f_3 = 
f_4 [  v_1 , v_2 , v_3 , v_4 ( v_3 )  ]
\] $$
It follows that 
$latex \[
\begin{array}{rcll}
\D{f_3}{v_1} 
& = & \D{f_4}{v_1} 
& =  0.25
\\
\D{f_3}{v_2} & = & \D{f_4}{v_2}  & = 0
\\
\D{f_3}{v_3} 
& = & \D{f_4}{v_3} + 
	\D{f_4}{v_4} * \D{v_4}{v_3} 
& =  1.25
\end{array}
\] $$


$head Index 3: f_2$$
The previous operation has index 3,
$latex \[
	v_3 = v_2 / 1
\] $$
We define the function 
$latex f_2 (  v_1 , v_2 ) $$
as equal to $latex f_3 $$
except that $latex v_3 $$ is eliminated using this operation; i.e.,
$latex \[
f_2 = 
f_4 [  v_1 , v_2 , v_3 ( v_2 )  ]
\] $$
It follows that 
$latex \[
\begin{array}{rcll}
\D{f_2}{v_1} 
& = & \D{f_3}{v_1} 
& =  0.25
\\
\D{f_2}{v_2} & = & \D{f_3}{v_2}  +
	\D{f_3}{v_3} * \D{v_3}{v_2}
& = 1.25
\end{array}
\] $$

$head Index 2: f_1$$
The previous operation has index 1,
$latex \[
	v_2 = 1 * v_1
\] $$
We define the function 
$latex f_1 (  v_1 ) $$
as equal to $latex f_2 $$
except that $latex v_2 $$ is eliminated using this operation; i.e.,
$latex \[
f_1 = 
f_2 [  v_1 , v_2 ( v_1 )  ]
\] $$
It follows that 
$latex \[
\begin{array}{rcll}
\D{f_1}{v_1} & = & \D{f_2}{v_1}  +
	\D{f_2}{v_2} * \D{v_2}{v_1}
& = 1.5
\end{array}
\] $$

Note that $latex v_1$$ is equal to $latex x$$,
so the derivative of $syntax%exp_eps(%x%, %epsilon%)%$$ 
at $italic x$$ equal to .5 and $italic epsilon$$ equal .2 is
1.5 in the $italic x$$ direction and zero in the $italic epsilon$$ direction.
We also note that 
$cref/forward/exp_eps_for/$$ forward mode gave the 
same result for the partial in the $italic x$$ direction.


$children%
	introduction/exp_apx/exp_eps_rev.cpp
%$$

$head Verification$$
The file $xref/exp_eps_rev.cpp/$$ contains a routine 
that verifies the values computed above.
It returns true for success and false for failure.
It only tests the partial derivatives of
$latex f_j$$ that are different from those of $latex f_{j+1}$$.

$head Exercises$$
$list number$$
Consider the case where $latex x = .1$$
and we first preform a zero order forward mode sweep
for the operation sequence used above (in reverse order).
What are the results of a 
first order reverse mode sweep; i.e.,
what are the corresponding values for 
$latex \D{f_j}{v_k}$$ for all $latex j, k$$ such that
$latex \D{f_j}{v_k} \neq 0$$.
$lnext
Create a modified version of 
$cref/exp_eps_rev.cpp/$$ 
that verifies the values you obtained for the previous exercise.
Also create and run a main program that reports the result
of calling the modified version of
$cref/exp_eps_rev.cpp/$$.
$lend

$end
-----------------------------------------------------------------------------
