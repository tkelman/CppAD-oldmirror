-----------------------------------------------------------------------------
CppAD: C++ Algorithmic Differentiation: Copyright (C) 2003-07 Bradley M. Bell

CppAD is distributed under multiple licenses. This distribution is under
the terms of the 
                    Common Public License Version 1.0.

A copy of this license is included in the COPYING file of this distribution.
Please visit http://www.coin-or.org/CppAD/ for information on other licenses.
-----------------------------------------------------------------------------
$begin exp_eps.hpp$$
$spell
	exp_eps
$$

$section exp_eps: Implementation$$
$index implementation, exp_eps$$
$index exp_eps, implementation$$

$code
$verbatim%introduction/exp_apx/exp_eps.hpp%0%// BEGIN PROGRAM%// END PROGRAM%$$
$$

$end
-----------------------------------------------------------------------------
$begin exp_eps.cpp$$
$spell
	exp_eps
$$

$section exp_eps: Test of exp_eps$$
$index test, exp_eps$$
$index exp_eps, test$$

$code
$verbatim%introduction/exp_apx/exp_eps.cpp%0%// BEGIN PROGRAM%// END PROGRAM%$$
$$

$end
-----------------------------------------------------------------------------
$begin exp_eps_for0$$
$spell
	cpp
	exp_eps_seq
	bool
$$

$section exp_eps: Operation Sequence and Zero Order Forward Mode$$

$index exp_eps, operation sequence$$
$index example, operation sequence$$
$index operation, sequence example$$
$index sequence, example operation$$

$index zero, order forward$$
$index order, zero forward$$
$index forward, zero order$$

$head Mathematical Form$$
Suppose that we use the algorithm $xref/exp_eps.hpp/$$
to compute $syntax%exp_eps(%x%, %epsilon%)%$$
with $italic x$$ is equal to .5
and $italic epsilon$$ is equal to .2. 
For this case, 
the mathematical form for the operation sequence 
corresponding to the $code exp_eps$$ is
$latex \[
	f( x , \varepsilon ) = 1 + x + x^2 / 2  
\] $$
Note that, for these particular values of $italic x$$ and $italic epsilon$$,
this is the same as the mathematical form for
$cref/exp_2/exp_2_for0/Mathematical Form/$$.


$head Operation Sequence$$
We consider the 
$cref/operation sequence/glossary/Operation/Sequence/$$
corresponding to the algorithm $xref/exp_eps.hpp/$$
with the argument $italic x$$ is equal to .5
and $italic epsilon$$ is equal to .2. 

$subhead Variable$$
We refer to values that depend on the input variables
$italic x$$ and $italic epsilon$$ as variables.

$subhead Parameter$$
We refer to values that do not depend on the input variables
$italic x$$ or $italic epsilon$$ as parameters.
Operations where the result is a parameter are not traced
in the operation sequence below.


$subhead Index$$
The Index column contains the index in the operation sequence
of the corresponding atomic operation and variable. 
A Forward sweep starts with the first operation 
and ends with the last.

$subhead Code$$
The Code column contains the C++ source code corresponding 
to the corresponding atomic operation in the sequence. 

$subhead Operation$$
The Operation column contains the 
mathematical function corresponding to each atomic operation in the sequence.

$subhead Zero Order$$
The Zero Order column contains the 
$cref/zero order derivative/exp_2_for0/Zero Order Derivative/$$
for the corresponding variable in the operation sequence.
Forward mode refers to the fact that
these coefficients are computed in the same order as the original algorithm;
i.e., in order of increasing index.


$subhead Trace$$
$center
$table
$bold Index$$
	$cnext $pre  $$ $cnext $bold Code$$ 
	$cnext $pre  $$ $cnext $bold Operation$$
	$cnext $pre  $$ $cnext $bold Zero Order$$
$rnext
1
	$cnext $pre  $$ $cnext $code abs_x = x;$$
	$cnext $cnext $latex v_1 = x $$
	$cnext $cnext $latex v_1^{(0)} = 0.5$$
$rnext
2
	$cnext $pre  $$ $cnext $code temp  = term * abs_x;$$
	$cnext $cnext $latex v_2 = 1 * v_1 $$
	$cnext $cnext $latex v_2^{(0)} = 0.5$$
$rnext
3
	$cnext $pre  $$ $cnext $code term = temp / Type(k);$$
	$cnext $cnext $latex v_3 = v_2 / 1$$
	$cnext $cnext $latex v_3^{(0)} = 0.5$$
$rnext
4
	$cnext $pre  $$ $cnext $code sum  = sum + term;$$
	$cnext $cnext $latex v_4 = 1 + v_3 $$
	$cnext $cnext $latex v_4^{(0)} = 1.5$$
$rnext
5
	$cnext $pre  $$ $cnext  $code temp  = term * abs_x;$$
	$cnext $cnext $latex v_5 = v_3 * v_1 $$
	$cnext $cnext $latex v_5^{(0)} = 0.25$$
$rnext
6
	$cnext $pre  $$ $cnext $code term = temp / Type(k);$$
	$cnext $cnext $latex v_6 = v_5 / 2$$
	$cnext $cnext $latex v_6^{(0)} = 0.125$$
$rnext
7
	$cnext $pre  $$ $cnext $code sum  = sum + term;$$
	$cnext $cnext $latex v_7 = v_4 + v_6 $$
	$cnext $cnext $latex v_7^{(0)} = 1.625$$
$tend
$$

$head Return  Value$$
The return value for this case is
$latex \[
y^{(0)} = f ( x^{(0)} , \varepsilon^{(0)} ) = v_7^{(0)} = 1.625
\] $$

$head Comparisons$$
If $italic x$$ were negative,
or if $italic epsilon$$ were a much smaller or much larger value,
the results of the following comparisons could be different:
$codep
	if( Type(0) > x ) 
	while(term > epsilon)
$$
This in turn would result in a different operation sequence.
Thus the operation sequence above only corresponds to 
$cref/exp_eps.hpp/$$
for values of $italic x$$ and $italic epsilon$$ within a certain range.
Note that there is a neighborhood
of $latex x = 0.5$$ for which the comparisons would have the 
same result and hence the operation sequence would be the same.

$children%
	introduction/exp_apx/exp_eps_for0.cpp
%$$

$head Verification$$
The file $xref/exp_eps_for0.cpp/$$ contains a routine 
that verifies the values computed above.
It returns true for success and false for failure.

$head Exercises$$
$list number$$
Suppose that $latex x^{(0)} = .1$$,
what is the result of a zero order forward sweep for 
the operation sequence above; 
i.e., what are the corresponding values for
$latex v_1^{(0)} , v_2^{(0)} , \ldots , v_7^{(0)}$$.
$lnext
Create a modified version of 
$cref/exp_eps_for0.cpp/$$ that verifies the values you obtained
for the previous exercise.
$lnext
Create and run a main program that reports the result of calling 
the modified version 
of $cref/exp_eps_for0.cpp/$$ in the previous exercise.
$lend

$end
-----------------------------------------------------------------------------
$begin exp_eps_for1$$
$spell
	Taylor
	exp_eps_for
$$

$section exp_eps: First Order Forward Mode$$

$index first, order forward$$
$index order, first forward$$
$index forward, first order$$


$head First Order Derivative$$
$index first, order derivative$$
$index order, first derivative$$
$index derivative, first order$$
We are given a Taylor expansion for $latex [ x(t) , \varepsilon(t) ]$$ 
near $latex t = 0$$ defined by
$latex \[
\begin{array}{rcl}
	x(t) & = & x^{(0)} + x^{(1)} * t 
	\\
	\varepsilon(t) & = & \varepsilon^{(0)} + \varepsilon^{(1)} * t
\end{array}
\]$$
we call $latex x^{(0)}$$ ($latex \varepsilon^{(0)}$$) the zero,
and $latex x^{(1)}$$  ($latex \varepsilon^{(1)}$$) the first,
order derivative for $latex x(t)$$ ($latex \varepsilon (t)$$).

$head Mathematical Form$$
Suppose that we use the algorithm $xref/exp_eps.hpp/$$
to compute $syntax%exp_eps(%x%, %epsilon%)%$$
with $italic x$$ is equal to .5
and $italic epsilon$$ is equal to .2. 
For this case, the mathematical form for the operation sequence
corresponding to $code exp_eps$$ is
$latex \[
f ( x , \varepsilon ) =   1 + x + x^2 / 2  
\] $$

$head Operation Sequence$$
We consider the case where $cref/exp_eps.hpp/$$ is executed
with $latex x = .5$$ and $latex \varepsilon = .2$$.

$subhead Index$$
The Index column contains the index in the operation sequence
of the corresponding atomic operation. 
A Forward sweep starts with the first operation 
and ends with the last.

$subhead Operation$$
The Operation column contains the 
mathematical function corresponding to each atomic operation in the sequence.

$subhead Zero Order$$
The Zero Order column contains the Zero order derivatives
for the corresponding variable in the operation sequence
(see $cref/zero order trace/exp_2_for1/Operation Sequence/Trace/$$).

$subhead Derivative$$
The Derivative column contains the
mathematical function corresponding to the derivative
with respect to $latex t$$ for each operation in the sequence.

$subhead First Order$$
The First Order column contains the First order derivatives
for the corresponding variable in the operation sequence; i.e.,
$latex \[
	v_j (t) = v_j^{(0)} + v_j^{(1)} t
\] $$
We use $latex x^{(0)} = 1$$ and $latex \varepsilon^{(1)} = 0$$,
so that differentiation with respect to $latex t$$ 
is the same partial differentiation with respect to $latex x$$.


$subhead Trace$$

$center
$table
$bold Index$$
	$cnext $pre  $$ $cnext $bold Operation$$ 
	$cnext $pre  $$ $cnext $bold Zero Order$$
	$cnext $pre  $$ $cnext $bold Derivative$$
	$cnext $pre  $$ $cnext $bold First Order$$
$rnext
1
	$cnext $pre  $$ $cnext $latex v_1 = x $$
	$cnext $cnext 0.5
	$cnext $cnext 
	$latex v_1^{(1)} = x^{(1)}  $$
	$cnext $cnext  $latex v_1^{(1)} = 1$$
$rnext
2
	$cnext $pre  $$ $cnext $latex v_2 = 1 * v_1$$
	$cnext $cnext 0.5
	$cnext $cnext 
	$latex v_2^{(1)} = 1 * v_1^{(1)}$$
	$cnext $cnext $latex v_2^{(1)} = 1$$
$rnext
3
	$cnext $pre  $$ $cnext $latex v_3 = v_2 / 1$$
	$cnext $cnext 0.5
	$cnext $cnext 
	$latex v_3^{(1)} = v_2^{(1)} / 1$$
	$cnext $cnext $latex v_3^{(1)} = 1$$
$rnext
4
	$cnext $pre  $$ $cnext $latex v_4 = 1 + v_3$$
	$cnext $cnext 1.5
	$cnext $cnext 
	$latex v_4^{(1)} = v_3^{(1)} $$
	$cnext $cnext $latex v_4^{(1)} = 1$$
$rnext
5
	$cnext $pre  $$ $cnext $latex v_5 = v_3 * v_1$$
	$cnext $cnext 0.25
	$cnext $cnext 
	$latex v_5^{(1)} = v_3^{(1)} * v_1^{(0)} + v_3^{(0)} * v_1^{(1)}$$
	$cnext $cnext $latex v_5^{(1)} = 1$$
$rnext
6
	$cnext $pre  $$ $cnext $latex v_6 = v_5 / 2$$
	$cnext $cnext 0.125
	$cnext $cnext 
	$latex v_6^{(1)} = v_5^{(1)} / 2$$
	$cnext $cnext $latex v_6^{(1)} = 0.5$$
$rnext
7
	$cnext $pre  $$ $cnext $latex v_7 = v_4 + v_6$$
	$cnext $cnext 1.625
	$cnext $cnext 
	$latex  v_7^{(1)} = v_4^{(1)} + v_6^{(1)}$$
	$cnext $cnext $latex  v_7^{(1)} = 1.5$$
$tend
$$

$head Return Value$$
The return value for this case is
$latex \[
	y^{(1)} = \partial_x f ( x^{(0)} ) = v_7^{(1)} = 1.5
\] $$


$children%
	introduction/exp_apx/exp_eps_for1.cpp
%$$

$head Verification$$
The file $xref/exp_eps_for1.cpp/$$ contains a routine 
that verifies the values computed above.
It returns true for success and false for failure.

$head Exercises$$
$list number$$
Suppose that $latex x = .1$$,
what are the results of a zero and first order forward mode sweep for 
the operation sequence above; 
i.e., what are the corresponding values for
$latex v_1^{(0)}, v_2^{(0)}, \cdots , v_7^{(0)}$$ and
$latex v_1^{(1)}, v_2^{(1)}, \cdots , v_7^{(1)}$$ ?
$lnext
Create a modified version of $cref/exp_eps_for1.cpp/$$ that verifies 
the derivative values from the previous exercise.
Also create and run a main program that reports the result
of calling the modified version of
$cref/exp_eps_for1.cpp/$$.
$lnext
Suppose that $latex x = .1$$ and $latex epsilon = .2$$,
what is the operation sequence corresponding to 
$syntax%
	exp_eps(%x%, %epsilon%)
%$$
$lend

$end
-----------------------------------------------------------------------------
$begin exp_eps_rev1$$
$spell
	exp_eps_rev
$$

$section exp_eps: First Order Reverse Mode$$

$index first, order reverse$$
$index order, first reverse$$
$index reverse, first order$$

$head First Order Reverse$$
First order reverse mode uses the 
$cref/operation sequence/exp_eps_for0/Operation Sequence/$$
and 
$cref/zero order/exp_eps_for0/Operation Sequence/Zero Order/$$
forward sweep values
to compute the first order derivative
of one dependent variables with respect to all the independent variables. 
The computations are done in the reverse order of the original algorithm.

$head f_7$$
In reverse mode we choose one dependent variable and
compute its derivative with respect to all the independent variables.
For our example, we chose the value returned by $cref/exp_eps.hpp/$$
which is $latex v_7$$.
We begin with the function $latex f_7$$ where $latex v_7$$ 
is both an argument and the value of the function; i.e.,
$latex \[
\begin{array}{rcl}
f_7 ( v_1 , v_2 , v_3 , v_4 , v_5 , v_6 , v_7 ) & = & v_7 
\\
\D{f_7}{v_7} & = & 1
\end{array}
\] $$
All the other partial derivatives of $latex f_7$$ are zero.

$head Index 7: f_6$$
The last operation has index 7, 
$latex \[
	v_7 =   v_4 + v_6  
\] $$
We define the function 
$latex f_6 ( v_1 , v_2 , v_3 , v_4 , v_5 , v_6 ) $$
as equal to $latex f_7$$
except that $latex v_7$$ is eliminated using 
this operation; i.e.
$latex \[
f_6  = 
f_7 [ v_1 , v_2 , v_3 , v_4 , v_5 , v_6 , v_7 ( v_4 , v_6 ) ]
\] $$
It follows that 
$latex \[
\begin{array}{rcll}
\D{f_6}{v_4} 
& = & \D{f_7}{v_4} + 
	\D{f_7}{v_7} * \D{v_7}{v_4} 
& = 1
\\
\D{f_6}{v_6} 
& = & \D{f_7}{v_6} + 
	\D{f_7}{v_7} * \D{v_7}{v_6} 
& = 1
\end{array}
\] $$
All the other partial derivatives of $latex f_6$$ are zero.

$head Index 6: f_5$$
The previous operation has index 6, 
$latex \[
	v_6 = v_5 / 2
\] $$
We define the function 
$latex f_5 (  v_1 , v_2 , v_3 , v_4 , v_5 ) $$
as equal to $latex f_6 $$
except that $latex v_6 $$ is eliminated using this operation; i.e.,
$latex \[
f_5 = 
f_6 [  v_1 , v_2 , v_3 , v_4 , v_5 , v_6 ( v_5 ) ]
\] $$
It follows that 
$latex \[
\begin{array}{rcll}
\D{f_5}{v_4} 
& = & \D{f_6}{v_4} 
& = 1
\\
\D{f_5}{v_5} 
& = & \D{f_6}{v_5} + 
	\D{f_6}{v_6} * \D{v_6}{v_5} 
& = 0.5
\end{array}
\] $$
All the other partial derivatives of $latex f_5$$ are zero.

$head Index 5: f_4$$
The previous operation has index 5,
$latex \[
	v_5 = v_3 * v_1
\] $$
We define the function 
$latex f_4 (  v_1 , v_2 , v_3 , v_4 ) $$
as equal to $latex f_5 $$
except that $latex v_5 $$ is eliminated using this operation; i.e.,
$latex \[
f_4 = 
f_5 [  v_1 , v_2 , v_3 , v_4 , v_5 ( v_3 , v_1 )  ]
\] $$
Given the information from the forward sweep, we have
$latex v_3 =  0.5 $$ and $latex v_1 = 0.5 $$.
It follows that 
$latex \[
\begin{array}{rcll}
\D{f_4}{v_1} 
& = & \D{f_5}{v_1} + 
	\D{f_5}{v_5} * \D{v_5}{v_1} 
& =  0.25
\\
\D{f_4}{v_2} & = & \D{f_5}{v_2}  & = 0
\\
\D{f_4}{v_3} 
& = & \D{f_5}{v_3} + 
	\D{f_5}{v_5} * \D{v_5}{v_3} 
& =  0.25
\\
\D{f_4}{v_4}
& = & \D{f_5}{v_4} 
& = 1
\end{array}
\] $$

$head Index 4: f_3$$
The previous operation has index 4,
$latex \[
	v_4 = 1 + v_3
\] $$
We define the function 
$latex f_3 (  v_1 , v_2 , v_3 ) $$
as equal to $latex f_4 $$
except that $latex v_4 $$ is eliminated using this operation; i.e.,
$latex \[
f_3 = 
f_4 [  v_1 , v_2 , v_3 , v_4 ( v_3 )  ]
\] $$
It follows that 
$latex \[
\begin{array}{rcll}
\D{f_3}{v_1} 
& = & \D{f_4}{v_1} 
& =  0.25
\\
\D{f_3}{v_2} & = & \D{f_4}{v_2}  & = 0
\\
\D{f_3}{v_3} 
& = & \D{f_4}{v_3} + 
	\D{f_4}{v_4} * \D{v_4}{v_3} 
& =  1.25
\end{array}
\] $$


$head Index 3: f_2$$
The previous operation has index 3,
$latex \[
	v_3 = v_2 / 1
\] $$
We define the function 
$latex f_2 (  v_1 , v_2 ) $$
as equal to $latex f_3 $$
except that $latex v_3 $$ is eliminated using this operation; i.e.,
$latex \[
f_2 = 
f_4 [  v_1 , v_2 , v_3 ( v_2 )  ]
\] $$
It follows that 
$latex \[
\begin{array}{rcll}
\D{f_2}{v_1} 
& = & \D{f_3}{v_1} 
& =  0.25
\\
\D{f_2}{v_2} & = & \D{f_3}{v_2}  +
	\D{f_3}{v_3} * \D{v_3}{v_2}
& = 1.25
\end{array}
\] $$

$head Index 2: f_1$$
The previous operation has index 1,
$latex \[
	v_2 = 1 * v_1
\] $$
We define the function 
$latex f_1 (  v_1 ) $$
as equal to $latex f_2 $$
except that $latex v_2 $$ is eliminated using this operation; i.e.,
$latex \[
f_1 = 
f_2 [  v_1 , v_2 ( v_1 )  ]
\] $$
It follows that 
$latex \[
\begin{array}{rcll}
\D{f_1}{v_1} & = & \D{f_2}{v_1}  +
	\D{f_2}{v_2} * \D{v_2}{v_1}
& = 1.5
\end{array}
\] $$

Note that $latex v_1$$ is equal to $latex x$$,
so the derivative of $syntax%exp_eps(%x%, %epsilon%)%$$ 
at $italic x$$ equal to .5 and $italic epsilon$$ equal .2 is
1.5 in the $italic x$$ direction and zero in the $italic epsilon$$ direction.
We also note that 
$cref/forward/exp_eps_for1/$$ forward mode gave the 
same result for the partial in the $italic x$$ direction.


$children%
	introduction/exp_apx/exp_eps_rev1.cpp
%$$

$head Verification$$
The file $xref/exp_eps_rev1.cpp/$$ contains a routine 
that verifies the values computed above.
It returns true for success and false for failure.
It only tests the partial derivatives of
$latex f_j$$ that are different from those of $latex f_{j+1}$$.

$head Exercises$$
$list number$$
Consider the case where $latex x = .1$$
and we first preform a zero order forward mode sweep
for the operation sequence used above (in reverse order).
What are the results of a 
first order reverse mode sweep; i.e.,
what are the corresponding values for 
$latex \D{f_j}{v_k}$$ for all $latex j, k$$ such that
$latex \D{f_j}{v_k} \neq 0$$.
$lnext
Create a modified version of 
$cref/exp_eps_rev1.cpp/$$ 
that verifies the values you obtained for the previous exercise.
Also create and run a main program that reports the result
of calling the modified version of
$cref/exp_eps_rev1.cpp/$$.
$lend

$end
-----------------------------------------------------------------------------
