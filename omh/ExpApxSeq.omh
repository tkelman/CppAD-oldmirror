/* -----------------------------------------------------------------------
CppAD: C++ Algorithmic Differentiation: Copyright (C) 2003-06 Bradley M. Bell

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
------------------------------------------------------------------------ */
/*
$begin ExpApxSeq$$
$spell
	cpp
	ExpApxSeq
	bool
$$

$section A Type Operation Sequence Generated by ExpApx$$

$index ExpApx, operation sequence$$
$index operation, sequence$$
$index sequence, operation$$

$head Operation Sequence$$
An atomic $italic Type$$ operation is an operation
that has a $italic Type$$ result and is not made up of 
other more basic operations.
A sequence of atomic $italic Type$$ operations is called a
$italic Type$$ operation sequence.
Given an C++ algorithm and its inputs,
there is a corresponding $italic Type$$ operation sequence for each type. 
If $italic Type$$ is clear from the context, 
we drop it and just refer to the operation sequence.

$head Generated by ExpApx$$
Suppose that we use the algorithm $xref/ExpApx.hpp/$$
to compute $latex ExpApx(x, e)$$ 
with $latex x$$ is equal to .5
and $latex e$$ is equal to .2. 
We use the symbol $latex v_j$$ for the value assigned
to the object $latex v$$ in the $th j$$ execution of loop in the algorithm.

$subhead Constants$$
The initialization section always sets
$latex r_0$$,
$latex s_0$$,
and
$latex k_0$$ equal to one.
Hence the $italic Type$$ values 
$latex r_0$$, $latex s_0$$ and $latex k_0$$ are constants; i.e.,
they cannot depend on the input variables $italic x$$ or $italic e$$.



$subhead Variables$$
In the table below, 
the C++ source code is listed on the left,
the corresponding symbol is in the next column,
the atomic operation is in the next column,
and the resulting value of the symbol when 
$latex x = .5$$ and $latex e = .2$$ is listed on the right.
Note that the operations in the following assignment statements
are not part of the operation sequence 
for this value of $italic x$$ and $italic e$$
$codep
	if( Type(0) > x ) a = -x;
	if( Type(0) > x ) s = Type(1) / s;
$$
Also note the comparisons
$code r > e$$ and $code  Type(0) > x $$
have results of type
$code bool$$ and hence is not part of the operation sequence.
$center
$table
$bold Code$$ 
	$cnext $pre  $$ $cnext $bold Symbol$$
	$cnext $pre  $$ $cnext $bold Operation$$
	$cnext $pre  $$ $cnext $bold Value$$
	$rnext
$code a = x$$
	$cnext $cnext $latex a_0 $$
	$cnext $cnext $latex = x $$ 
	$cnext $cnext = 0.5      
$rnext
$code q  = a * r$$
	$cnext $cnext $latex q_1 $$
	$cnext $cnext $latex = r_0 * a_0 $$ 
	$cnext $cnext = 0.5      
$rnext
$code r  = q / k$$
	$cnext $cnext $latex r_1 $$
	$cnext $cnext $latex = q_1 / k_0 $$ 
	$cnext $cnext = 0.5      
$rnext
$code s  = s + r$$
	$cnext $cnext $latex s_1 $$
	$cnext $cnext $latex = s_0 + r_1 $$ 
	$cnext $cnext = 1.5      
$rnext
$code k  = k + Type(1)$$
	$cnext $cnext $latex k_1 $$
	$cnext $cnext $latex = k_0 + 1 $$ 
	$cnext $cnext = 2        
$rnext
$code q  = a * r$$
	$cnext $cnext $latex q_2 $$
	$cnext $cnext $latex = r_1 * a_0 $$ 
	$cnext $cnext = 0.25     
$rnext
$code r  = q / k$$
	$cnext $cnext $latex r_2 $$
	$cnext $cnext $latex = q_2 / k_1 $$ 
	$cnext $cnext = 0.125    
$rnext
$code s  = s + r$$
	$cnext $cnext $latex s_2 $$
	$cnext $cnext $latex = s_1 + r_2 $$ 
	$cnext $cnext = 1.625    
$rnext
$code k  = k + Type(1)$$
	$cnext $cnext $latex k_2 $$
	$cnext $cnext $latex = k_1 + 1 $$ 
	$cnext $cnext = 3        
$tend
$$
The return value of the algorithm for this case is
$latex s_2$$ which is equal to 1.625.
$pre

$$
Note that each operation above has a corresponding binary function.
If $latex x$$ were negative,
or if $latex e$$ were a much smaller or much larger value,
then the operation sequence would be different; i.e.,
the operations above only correspond to the our algorithm
for values of $latex x$$ and $latex e$$ within a certain range.

$head Symbols$$
$index operation, symbol$$
$index symbol, operation$$
The symbols for an operation sequence is a
sequence of unique names for each atomic operation.
For example, the symbols for the operation sequence above are:
$latex \[
	r_0, s_0, k_0, a_0, q_1, r_1, s_1, k_1, q_2, r_2, s_2
\]$$
In an abuse of notation, we use a symbol for both the
function and the value of the function corresponding to an atomic operation. 
Note each time a $italic Type$$ object is assigned a value
there is a different symbol corresponding to the assignment.

$children%
	Introduction/ExpApxSeq.cpp
%$$
$head Trace$$
$index trace, operation sequence$$
$index operation, sequence trace$$
$index sequence, operation trace$$
The file $xref/ExpApxSeq.cpp/$$ contains the routine $code ExpApxSeq$$ 
which traces this operation sequence 
and writes its output to a file called 
$code ExpSeqExample.out$$
(both these files are in the $code Introduction$$ directory).

$head ExpApxSeqMain.cpp$$
The following program 
executes the routine above with 
$latex x$$ is equal to .5 and $latex e$$ is equal to .2:
$code
$verbatim%Introduction/ExpApxSeqMain.cpp%0%// BEGIN PROGRAM%$$
$$


$head ExpApxSeq.out$$
The following trace
is generated when the program above is run:
$code
$verbatim%Introduction/ExpApxSeq.out%$$
$$

$end
*/
