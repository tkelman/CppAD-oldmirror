$Id$
/* --------------------------------------------------------------------------
CppAD: C++ Algorithmic Differentiation: Copyright (C) 2003-12 Bradley M. Bell

CppAD is distributed under multiple licenses. This distribution is under
the terms of the 
                    Common Public License Version 1.0.

A copy of this license is included in the COPYING file of this distribution.
Please visit http://www.coin-or.org/CppAD/ for information on other licenses.
-------------------------------------------------------------------------- */
$begin WishList$$
$spell
	Berger
	namespace
	omp_alloc
	iterator
	bools
	Microsoft
	inline
	std
	tanh
	cos
	booleans
	Jacobian
	recomputed
	Ipopt
	Adolc
	Fadbad
	Sacado
	xml
	hpp
	CondExp
	Vec
	Cpp
	Atan
	retape
	cppad
	nlp
$$

$section The CppAD Wish List$$
$index wish list$$
$index new, features$$
$index features, new$$

$head Atan2$$
$index atan2$$
The $cref/atan2/Atan2/$$ function could be made faster by adding
a special operator for it.

$head BenderQuad$$
See the $cref/problem/BenderQuad/Problem/$$ with the 
current $code BenderQuad$$ specifications.

$head CondExp$$
$index CondExp$$
Extend the conditional expressions $cref CondExp$$ so that they are 
valid for complex types by comparing real parts.
In addition, use this change to extend $cref LuRatio$$ so 
that it works with complex AD types.


$head Ipopt$$
$index cppad_ipopt_nlp$$
$list number$$
Create a separate documentation page for using $code cppad_ipopt_nlp$$
with the $cref/simple representation/cppad_ipopt_nlp/Simple Representation/$$. 

$lnext
The vector of sets $cref/sparsity pattern/glossary/Sparsity Pattern/$$
could be compared for speed with of vector of bools
(and used instead if it is faster).

$lnext
Perhaps it would help to cache the solution of the sparse Jacobian
and spare Hessian graph coloring algorithm.
Then, when the sparsity pattern does not depend on the argument value,
these colorings would not have to be recomputed.

$lnext
In the case where $codei%retape(%k%)%$$ is true for some $icode k$$,
one can still use the structure of the representation to compute a 
sparsity structure. Currently $code cppad_ipopt_nlp$$ uses a dense 
sparsity structure for this case

$lnext
The $icode new_x$$ flag could be used to avoid zero order forward mode
computations. Because the same $code ADFun$$ object is used at different
argument values, this would require forward mode at multiple argument values
(see $cref/multiple arguments/WishList/Multiple Arguments/$$). 

$lend

$head Library$$
$index compile, speed AD<double>$$
$index speed, compile AD<double>$$
$index AD<double>, compile speed$$
One could build a CppAD library for use with the type $code AD<double>$$.
This would speed up compilation for the most common usage where
the $icode Base$$ type is $code double$$.

$head Memory$$
The $cref thread_alloc$$ memory manager might be able to improve performance
of the $cref/multi_newton/thread_test.cpp/multi_newton/$$ timing using the
idea of allocating memory using a minimal chunk size. 
See end of page 118 and beginning of 119 in the article 
$icode {Hoard: a scalable memory allocator for multi-threaded applications$$,
by E.D. Berger et. al.


$head Multiple Arguments$$
$index speed, improve$$
It has been suggested that computing and storing forward mode
results for multiple argument values (and for multiple orders)
is faster for Adolc. 
Perhaps CppAD should allow for forward mode at multiple argument values
(perhaps multiple orders).

$head Numeric Limits$$
$index testing, machine epsilon$$
$index machine epsilon, testing$$
Use a multiple of $code std::numeric_limits<double>::epsilon()$$ instead
$code 1e-10$$ for a small number in correctness checks; e.g.,
see $cref tan.cpp$$.

$head Operation Sequence$$
$index sequence, operation$$
$index operation, sequence$$
It is possible to detect if the 
AD of $icode Base$$ 
$cref/operation sequence/glossary/Operation/Sequence/$$ 
does not depend on any of the
$cref/independent variable/glossary/Tape/Independent Variable/$$ values.
This could be returned as an extra
$cref seq_property$$.

$head Optimization$$
$index optimize, tape$$
$index tape, optimize$$

$subhead Expression Hashing$$
During expression sequence $cref/optimization/optimize/$$,
hash codes are used to detect expressions that have already
been computed.
Perhaps this should be done during the original forward mode recording. 

$subhead Microsoft Compiler$$
The Microsoft's Visual C++ Version 9.0 generates a warning of the form
$codei warning C4396:%...%$$ 
for every template function that is declared as a both a friend and inline
(it thinks it is only doing this for specializations of template functions).
The $code CPPAD_INLINE$$ preprocessor symbol is used to convert
these $code inline$$ directives to
empty code (if a Microsoft Visual C++ is used).
If it is shown to be faster and does not slow down CppAD with other compilers,
non-friend functions should be used to map these operations
to member functions so that both can be compiled inline.

$head Variable Pairs$$
Suppose that $icode x$$ is a variable 
and $codei%sin(%x%)%$$ is used in an expression.
The extra expression $codei%cos(%x%)%$$ is also computed
during a $cref Forward$$ calculation.
This is because the derivative of the original expression
is expressed in terms of the values of the other expression.
In general, 
the representation of the derivative of an expression to order $icode p$$ 
may include the derivative of another expression to order $icode%p%-1%$$.
In our example, if only the value $codei%sin(%x%)%$$ 
is requested, it is not necessary to compute $codei%cos(%x%)%$$.
We should remove the computation of extra expressions derivatives that are 
not need to compute the requested derivative of the original expression. 

$head Software Guidelines$$

$subhead Boost$$
The following is a list of some software guidelines taken from
$href%http://www.boost.org/more/lib_guide.htm#Guidelines%boost%$$.
These guidelines are not followed by the current CppAD source code,
but perhaps they should be:

$list number$$
Names (except as noted below) 
should be all lowercase, with words separated by underscores.
For example, acronyms should be treated as ordinary names 
(xml_parser instead of XML_parser).

$lnext
Template parameter names should begin with an uppercase letter.

$lnext
Use spaces rather than tabs.  

$lend

$head Sparsity Patterns$$
$index sparsity, pattern parallel$$
$index pattern, sparsity parallel$$
$index parallel, sparsity pattern$$

$subhead Faster Set Operations$$
$list number$$
The sparse set $code add_element$$ operation could be made faster
by cashing the iterator where the $code std::set$$ inserts the 
previous element. See the $code add_element$$ routine in the file
$code sparse_set.hpp$$. 
$lnext
The memory allocation by standard set during sparsity calculations
should be changed over to use $cref omp_alloc$$
(requires making a standard allocator interface to $code omp_alloc$$).
$lnext
The $cref user_atomic$$ operations should allow the user to chose vectors
of bits, instead of standard sets, for representing sets. This would
be more efficient for most cases.
$lend


$head Speed Testing$$
$index speed, extend tests$$
$index MS Windows, extend speed tests$$
Extend the speed tests for Adolc, Fadbad, and Sacado
to run under MS Windows.
Run the CppAD $cref speed$$ tests on a set of different machines
and operating systems.

$head Tracing$$
$index operation, sequence tracing$$
$index sequence, operation tracing$$
$index tracing, operation sequence$$
Add operation sequence tracing to the user API and documentation.

$head VecAD$$
$index VecAD, improve assignment$$
Make assignment operation in $cref VecAD$$ like
assignment in $cref ad_ctor$$ and $cref ad_assign$$.
This will fix slicing to $code int$$ when assigning
from $code double$$ to 
$code VecAD< AD<double> >::reference$$ object.

$head Vector Element Type$$
Change cross references from 
$cref/elements of a specified type/SimpleVector/Elements of Specified Type/$$
to
$cref/value_type/SimpleVector/Value Type/$$.

$end
