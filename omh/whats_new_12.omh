$Id$
/* --------------------------------------------------------------------------
CppAD: C++ Algorithmic Differentiation: Copyright (C) 2003-12 Bradley M. Bell

CppAD is distributed under multiple licenses. This distribution is under
the terms of the 
                    Common Public License Version 1.0.

A copy of this license is included in the COPYING file of this distribution.
Please visit http://www.coin-or.org/CppAD/ for information on other licenses.
-------------------------------------------------------------------------- */

$begin whats_new_12$$
$spell
	num
	alloc
	makefile
	hpp
	gcc
	cppad-%yyyymmdd%
	lpthread
	xout
	fabs
	fcur
	CppAD
	openmp
$$

$section CppAD Changes and Additions During 2012$$

$head Introduction$$
This section contains a list of the changes to CppAD during 2012
(in reverse order by date).
The purpose of this section is to
assist you in learning about changes between various versions of CppAD.

$head 03-02$$
$list number$$
Change the name $code simple_ad.cpp$$ to $cref team_example.cpp$$
$lnext
The multi-threading $code team_example.cpp$$ example was changed to use 
$latex f(x) = \sqrt{ x^2 }$$ instead of the function
$latex {\rm atan2} [ \sin(x) , \cos (x) ]$$
(both functions should behave like the identity function $latex f(x) = x$$).
This enabled the removal of $code multi_thread/arc_tan.cpp$$.
$lnext
In $cref team_example.cpp$$ check that all of the threads
pass their individual test; i.e. $codei%work_all_[%thread_num%]%.ok%$$
is true for all $icode thread_num$$.
$lend

$head 02-11$$
$list number$$
The requirements in 
$cref base_member$$ were missing from the $cref base_require$$ documentation.
In addition,
the $cref base_require.cpp$$ example has been added.
$lend
The specifications for $cref memory_leak$$ where changes so that
calling routine specifies the amount of static memory to add.
In addition,
it is now possible to call 
$code memory_leak$$ when $cref/num_threads/ta_num_threads/$$ 
is greater than one
(still can't be in parallel mode).

$head 02-10$$
$list number$$
Add the missing Base class requirements in
the entire $cref base_member$$ section
and under the $cref/Output Operator/base_require/Output Operator/$$
in the $cref base_require$$ section.
$lnext
Add the $cref base_alloc.hpp$$ example.
$lend


$head 02-09$$
$list number$$
Add the $icode set_static$$ to $cref memory_leak$$.
This is necessary for testing base types that allocate memory
for each element.
$lnext
Fix memory allocation bug in $code cppad/local/pod_vector.hpp$$
when each element of the $cref/Base/base_require/$$ type allocated memory.
$lend

$head 01-30$$
Make another attempt to fix linking with boost threads where the wrong
version of the library is in the system include directory; i.e.,
to have $cref/BOOST_DIR/InstallUnix/BoostDir/$$ override the default
library.

$head 01-27$$
There were some problems with 
$cref/configure's/InstallUnix/Configure/$$ automatic detection of
the boost multi-threading library. 
These have been fixed.

$head 01-24$$
It used to be that $cref thread_alloc$$ did not hold onto memory
when $icode num_threads$$ was one in the previous call to
$cref/parallel_setup/ta_parallel_setup/$$.
Holding onto memory is now controlled by the separate routine
$cref/hold_memory/ta_hold_memory/$$.
This give the user more control over the memory allocator
and the ability to obtain a speed up even 
when there is only one thread.
To convert old code to the new interface, after each call to
$codei%
	thread_alloc::parallel_setup(%num_threads%, %in_parallel%, %thread_num%);
%$$
put the following call
$codei%
	thread_alloc::hold_memory(%num_threads% > 1);
%$$

$head 01-23$$
Change variable notation and use $cref optimize$$ in
$cref mul_level.cpp$$.

$head 01-20$$
$list number$$
Add the example $cref change_const.cpp$$
which shows how to compute derivatives of functions that have
parameters that can change (but derivatives are not computed 
with respect to these parameters).
$lnext
The documentation for machine $cref epsilon$$
has been improved.
(The fact that it can be used for $icode Base$$ types was missing.)
$lend

$head 01-19$$
$list number$$
In cases where $code test.sh$$ is trivial,
put its operations in corresponding makefile.
$lnext
Fix problem compiling $code cppad/speed/sparse_evaluate.hpp$$
under gcc on Fedora 17.
$lnext
Run $code multi_thread/test.sh$$ from source directory
(no need to copy to build directory).
$lend

$head 01-16$$
The test program $code multi_thread/test.sh$$ failed if the 
$cref/OpenmpFlags/InstallUnix/OpenmpFlags/$$ not present in the
$code configure$$ command.
This has been fixed.
In addition, this $code test.sh$$ has been made faster by cycling through
the available threading systems instead of doing every system for every
test. 

$head 01-15$$
Fix $code make test$$ so it works when 
$cref/configure/InstallUnix/Configure/$$ is run in the distribution directory
$codei%cppad-%yyyymmdd%$$
(not just when it is run in a different directory).


$head 01-12$$
The $code -lpthread$$ library was missing from the 
$cref multi_thread$$ test program linker command.
This has been fixed.

$head 01-07$$
$list number$$
A duplicated code block beginning with
$codep
	if( fabs( fcur ) <= epsilon_ )
$$
was removed from the routine $code multi_newton_worker$$, in the file
$cref multi_newton_work.cpp$$.

$lnext
The distance between solutions that are joined to one solution
has been corrected from $latex (b - a) / (2 n )$$ to
$latex (b - a) / n $$; see
$cref/xout/multi_newton.cpp/xout/$$.
The correction was in the file $cref multi_newton_work.cpp$$ where
$code sub_length_ / 2$$ was change to $code sub_length_$$.

$lend

$head 01-02$$
$list number$$
The $cref thread_alloc$$ memory allocator was changed to avoid
certain false sharing situations
(cases where two different thread were changing and using memory
that is on the same page of cache).
On one tests machine, the execution time for the 32 thread case for the test
$codep
	./openmp_test multi_newton 1 32 1000 4800 10 true
$$
improved from  0.0302 seconds to 0.0135 seconds.

$lnext
There was a problem with the correctness test section of the
$cref multi_newton_time.cpp$$ test.
The convergence criteria, and correctness criteria,
needed to be scaled by the largest argument values.
This was a problem with over a hundred zeros were included in the test
(and the largest argument value was $latex 100 \pi$$ or more).

$lnext
There was a problem with the way that
$cref/multi_newton_combine/multi_newton_work.cpp/multi_newton_combine/$$
joined two solutions into one.
It is possible that one of the solutions that needs to be joined is on 
the  boundary and very close to a solution in the next (or previous interval)
that is not on the  boundary. In this case,
the one with the smaller function value is chosen.

$lend
for the previous 

$end
